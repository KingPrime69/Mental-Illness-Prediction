"""
===============================================================================
NOTE:
This interface was created **only for visualization and testing purposes**.  
It simply loads the trained model and allows checking predictions on the dataset.  
It was **generated by AI** so it should **not be considered in the final project deliverable**.
===============================================================================
"""

from flask import Flask, request, render_template_string, redirect, url_for
import pandas as pd
import numpy as np
import pickle
from sklearn.preprocessing import LabelEncoder

# === Adjust if needed ===
MODEL_PATH = r"C:\Users\quent\Desktop\Mental-Illness-Prediction\app\data\models\random_forest_model_v0.5.pkl"
DATA_PATH  = r"C:\Users\quent\Desktop\Mental-Illness-Prediction\data\processed\cleaned_data\cleaned_data.csv"

TARGET = "Mental Illness"
VALID_TARGET = {"YES": 1, "NO": 0}

# --- Load model and dataset ---
pipe = pickle.load(open(MODEL_PATH, "rb"))
df = pd.read_csv(DATA_PATH)

# Keep only YES/NO rows for consistency
df = df[df[TARGET].isin(VALID_TARGET.keys())].copy()
y_true_bin = df[TARGET].map(VALID_TARGET)

# Raw features (same columns used during training)
X = df.drop(columns=[TARGET])

# Detect column types
cat_cols = X.select_dtypes(include=["object", "category", "bool"]).columns.tolist()
num_cols = X.select_dtypes(include=["number"]).columns.tolist()

# === Fit LabelEncoders on categorical columns ===
label_encoders = {}         # col -> LabelEncoder
label_mappings = {}         # col -> dict(str_value -> int)
X_le = X.copy()

for col in cat_cols:
    le = LabelEncoder()
    # Convert to string for stability (including NaN -> "nan")
    series_as_str = X[col].astype(str)
    le.fit(series_as_str)
    label_encoders[col] = le
    mapping = {cls: i for i, cls in enumerate(le.classes_)}
    label_mappings[col] = mapping
    # Replace with encoded values
    X_le[col] = series_as_str.map(mapping).astype(int)

# Ensure numeric columns are properly parsed
for col in num_cols:
    X_le[col] = pd.to_numeric(X_le[col], errors="coerce")

# Optional: simple imputation (replace NaN with -1)
X_le = X_le.fillna(-1)

# Keep the same feature order as during training (if available)
if hasattr(pipe, "feature_names_in_"):
    FEATURE_ORDER = list(pipe.feature_names_in_)
else:
    FEATURE_ORDER = list(X_le.columns)

# Prepare data for UI
X_display = X.reset_index(drop=True)            # raw values for display
X_le = X_le.reset_index(drop=True)              # encoded values for prediction
y_true_bin = y_true_bin.reset_index(drop=True)
y_true_text = df[TARGET].reset_index(drop=True)

app = Flask(__name__)

HTML = """
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Model Check - Mental Illness</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial; margin:24px; line-height:1.5}
    .card{max-width:1000px;margin:auto;padding:24px;border:1px solid #e5e7eb;border-radius:16px;box-shadow:0 6px 16px rgba(0,0,0,.06)}
    .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    select,input,button{padding:10px;border:1px solid #d1d5db;border-radius:10px}
    .pill{display:inline-block;padding:6px 10px;border-radius:999px;font-weight:600}
    .ok{background:#d1fae5;color:#065f46}
    .ko{background:#fee2e2;color:#991b1b}
    table{border-collapse:collapse;width:100%}
    th,td{border:1px solid #e5e7eb;padding:8px;text-align:left}
    th{background:#f3f4f6}
  </style>
</head>
<body>
  <div class="card">
    <h2>Check Model Prediction</h2>
    <form class="row" method="get" action="/">
      <label for="row_id">Observation (row):</label>
      <select id="row_id" name="row_id">
        {% for rid in sample_ids %}
          <option value="{{ rid }}" {% if rid == row_id %}selected{% endif %}>Row {{ rid }}</option>
        {% endfor %}
      </select>
      <button type="submit">Predict</button>
      <a href="{{ url_for('random_row') }}"><button type="button">Random Row</button></a>
    </form>

    {% if predicted is not none %}
      <hr>
      <h3>Result</h3>
      <p><strong>Ground truth:</strong> {{ true_text }} ({{ true_bin }})</p>
      <p><strong>Prediction:</strong> {{ pred_text }} ({{ predicted }})</p>
      {% if proba is not none %}
        <p><strong>Probability class YES (1):</strong> {{ '{:.3f}'.format(proba) }}</p>
      {% endif %}
      <p>
        <span class="pill {% if correct %}ok{% else %}ko{% endif %}">
          {% if correct %}Correct{% else %}Incorrect{% endif %}
        </span>
      </p>

      <h4>Features of row {{ row_id }}</h4>
      <table>
        <thead><tr><th>Column</th><th>Value</th></tr></thead>
        <tbody>
          {% for col, val in row_items %}
            <tr><td>{{ col }}</td><td>{{ val }}</td></tr>
          {% endfor %}
        </tbody>
      </table>
    {% endif %}
  </div>
</body>
</html>
"""

def encode_single_row_with_labelencoders(x_row_raw: pd.DataFrame) -> pd.DataFrame:
    """Convert a raw row into numeric features using pre-fitted LabelEncoders."""
    x = x_row_raw.copy()

    # Encode categorical columns with learned mappings
    for col in cat_cols:
        s = x[col].astype(str)
        mapping = label_mappings[col]
        # unseen values -> -1
        x[col] = s.map(mapping).fillna(-1).astype(int)

    # Ensure numeric columns are float, NaN -> -1
    for col in num_cols:
        x[col] = pd.to_numeric(x[col], errors="coerce")

    x = x.fillna(-1)

    # Reorder features to match training (if available)
    x = x.reindex(columns=FEATURE_ORDER, fill_value=-1)

    return x

@app.route("/")
def index():
    n = len(X_display)
    try:
        row_id = int(request.args.get("row_id", 0))
    except:
        row_id = 0
    row_id = max(0, min(row_id, n-1))

    sample_ids = list(range(min(100, n)))

    predicted = None
    proba = None
    true_bin = None
    true_text = None
    pred_text = None
    correct = None
    row_items = []

    if n > 0:
        # Raw row (for display) and encoded row (for prediction)
        x_row_raw = X_display.iloc[[row_id]]      # DataFrame (1 row)
        x_row_le  = encode_single_row_with_labelencoders(x_row_raw)

        # Prediction
        y_hat = pipe.predict(x_row_le)[0]
        predicted = int(y_hat)

        if hasattr(pipe, "predict_proba"):
            proba = float(pipe.predict_proba(x_row_le)[0][1])

        true_bin = int(y_true_bin.iloc[row_id])
        true_text = str(y_true_text.iloc[row_id])
        pred_text = "YES" if predicted == 1 else "NO"
        correct = (predicted == true_bin)
        row_items = list(zip(X_display.columns.tolist(), x_row_raw.iloc[0].tolist()))

    return render_template_string(
        HTML,
        sample_ids=sample_ids,
        row_id=row_id,
        predicted=predicted,
        proba=proba,
        true_bin=true_bin,
        true_text=true_text,
        pred_text=pred_text,
        correct=correct,
        row_items=row_items
    )

@app.route("/random")
def random_row():
    if len(X_display) == 0:
        return redirect(url_for("index"))
    return redirect(url_for("index", row_id=int(pd.Series(range(len(X_display))).sample(1).iloc[0])))

if __name__ == "__main__":
    app.run(debug=True)
